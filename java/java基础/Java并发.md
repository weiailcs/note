### 什么是线程？
答：线程是进程的一个实体，是CPU调度和分派的基本单位

### 什么是线程安全？
答：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。

### Java线程通信同步有几种方式
答：
1. 同步方法：synchronized关键字修饰的方法
2. 同步代码块：synchronized关键字修饰的语句块
3. 使用特殊域变量(volatile)实现线程同步。
4. 使用重入锁实现线程同步
5. 使用局部变量实现线程同步：使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，
副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

### 多线程共享数据
答：
1. 如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如，卖票系统就可以这么做。
2. 如果每个线程执行的代码不同，这时候需要用不同的Runnable对象，例如，设计4个线程。其中两个线程每次对j增加1，另外两个线程对j每次减1，银行存取款

有两种方法来解决此类问题：

1.将共享数据封装成另外一个对象，然后将这个对象逐一传递给各个Runnable对象，每个线程对共享数据的操作方法也分配到那个对象身上完成，这样容易实现针对数据进行各个操作的互斥和通信

2.将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。

### 互斥量和信号量的区别
答：
1. 互斥量用于线程的互斥，信号量用于线程的同步。（根本区别）
2. 互斥量值只能为0/1，信号量值可以为非负整数。
3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

### 线程是怎么实现的？线程有哪些方法？wait()是线程的方法吗？
答：
1. 继承Thread类创建线程。继承thread类，实现run方法，创建线程对象，调用start方法启动线程。
2. 实现Runnable接口创建线程。创建runnable接口实现类，重写run方法，创建该类的对象，并以此作为target创建线程，调用start方法启动线程。
3. 实现Callable接口通过FutureTask包装器来创建Thread线程。创建Callable接口实现类，实现call方法，创建该类的对象，并以此作为target创建线程，调用start方法启动线程。
4. 使用线程池

### wait和sleep的区别
答：
1. 这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。（sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。）
2. （最主要是）sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。sleep可以自动苏醒，wait方法不会自动苏醒，需要用notify唤醒。
3. 使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用

### 线程实现各有什么优缺点
答：
1. 继承Thread类创建线程。优点：代码简单。缺点：该类无法集成别的类。
2. 实现Runnable接口。优点：继承其他类。同一实现该接口的实例可以共享资源。缺点：代码复杂。
3. 实现Callable接口。优点：可以获得异步任务的返回值。
4. 创建线程池。实现自动化装配，易于管理，循环利用资源。

### 为什么要用start()方法去执行run()方法而不是直接调用run()方法？
答：run()方法只是thread类的一个普通方法，start()才是线程启动的方法。

### 线程状态
答：创建、运行、就绪、阻塞、死亡

### 上下文切换
答：多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。

### TheadLocal
答：线程局部变量，threadLocal为变量在每一个线程内部创建了一个副本，线程之间互不影响。

### 就绪状态和阻塞状态有什么区别，两者可以互相切换吗？
答：就绪状态是指调用了start方法，但是线程调度程序没有将该线程设置为当前线程，阻塞状态是指代码不继续执行，而在等待某个事件的发生后再继续运行，阻塞解除后，就会重新进入就绪状态。阻塞状态可以切换到就绪状态，反过来不行。

### 进程和线程切换开销对比
答：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。（进程切换会导致cache失效，而线程切换不会。cache是用来加速页表查找，也就是将虚拟地址转换为物理地址）

### Java中的锁
答：公平锁/非公平锁，可重入锁，独享锁/共享锁，互斥锁/读写锁，乐观锁/悲观锁，分段锁，偏向锁/轻量级锁/重量级锁，自旋锁。

### 公平锁和非公平锁
答：公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

（对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。）

### 可重入锁
答：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

（对于ReentrantLock和Synchronized而言，均是可重入锁）

### 独享锁/共享锁
答：独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。

（对于ReentrantLock和Synchronized而言，均是独享锁；对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。）

### 互斥锁/读写锁
答：上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
互斥锁在Java中的具体实现就是ReentrantLock
读写锁在Java中的具体实现就是ReadWriteLock

### 乐观锁/悲观锁
答：乐观锁，总是假设最好的情况，每次拿数据的时候都认为别人不会修改，所以不上锁，但是在更新的时候会判断一下在此期间别人有没有更新这个数据，可以使用版本号机制和CAS算法来实现。悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人拿这个数据就会阻塞，直到它拿到锁。eg:关系型数据库中的，行锁、表锁、读锁、写锁，操作之前上锁。

### 分段锁
答：分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。（以ConcurrentHashMap为例，ConcurrentHashMap中的分段锁称为Segment，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。）

（当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。）

### 偏向锁/轻量级锁/重量级锁
答：这三种锁是指锁的状态，并且是针对Synchronized。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

### 自旋锁
答：在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

### CAS的含义,ABA问题
答：CAS（Compare And Swap），比较再交换算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
ABA问题，eg:线程1从内存位置V中取了数据A，线程2从内存位置V中取了数据A，然后线程2对数据进行操作变成了B，然后又对数据进行了一些操作变为了A。解决这个问题可以使用添加版本号的方式，用 Java 中的提供的类AtomicStampedReference进行操作，AtomicStampedReference内部维护了一个“状态戳”。状态戳可类比为时间戳，是一个整数值，每一次修改对象值的同时，也要修改状态戳，从而区分相同对象值的不同状态。






### Java volatile
答：对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。内存包括共享主存和高速缓存（工作内存），Volatile关键字标识的变量，是指CPU从缓存读取数据时，要判断数据是否有效，如果缓存没有数据，则再从主存读取，主存就不存在是否有效的说法了。内存可见性意思是一个CPU核心对数据的修改，对其他CPU核心立即可见。

从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。

volatile 常用于多线程环境下的单次操作(单次读或者单次写)。

### 说一下volatile指令不可重排，怎么不可重排，为什么不可重排，重排会发生什么？
答：首先要了解一个概念，就是内存屏障（也叫内存栅栏），它是一个cpu的指令。作用有两个:
一是保证特定操作的执行顺序；
二是保证某些变量的内存可见性（volatile的内存可见性是利用该特性实现的）。由于编译器和处理器都能执行指令重排优化，如果在指令之间插入一条内存屏障则会告诉编译器和cup不管在任何情况下，无论任何指令都不能和这条内存屏障进行指令重排，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障的另外一个作用就是强制刷出各种CPU的缓存数据，因此在任何CPU上的线程都能读取到这些数据的最新值。

### 指令重排
答：
1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

### 并发三特性
答：
| 特性   | volatile     | synchronized | Lock     | Atomic   |
| ------ | ------------ | ------------ | -------- | -------- |
| 原子性 | 无法保障     | 可以保障     | 可以保障 | 可以保障 |
| 可见性 | 可以保障     | 可以保障     | 可以保障 | 可以保障 |
| 有序性 | 一定程度保障 | 可以保障     | 可以保障 | 无法保障 |

### volatile关键字和synchronized关键字
答：区别
1. volatile本质上告诉JVM当前变量是不确定的，需要从主存中读取；synchronized锁定当前变量，只有当前线程可以访问，其他线程阻塞。
2. volatile 仅能使用在变量级别；synchronized可以修饰类、方法、变量。
3. volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
4. volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
5. volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
6. （volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。）

### synchronized三种使用方式
答：
1. 修饰实例方法:作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。
2. 修饰静态方法:也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
3. 修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！

### synchronized锁状态切换
答：无锁/偏向锁/轻量级锁/重量级锁

### synchronized实现原理
答：synchronized与对象头有关，对象头由类型指针和标记字段组成，其中标记字段是用来存储对象运行时的数据（包括锁对象指针）。标记字段中的锁对象指针指向了一个monitor对象（每个对象都有一个对应的monitor对象，monitor对象是同步工具），线程在执行加了synchronized的代码段的时候，要先获取对象的monitor，执行完毕后释放monitor，此过程是互斥的，一次只有一个线程获取monitor，只有该线程释放monitor以后其它线程才能获取它。

### synchronized和lock的区别
答：
1. synchronized是（Java内置）关键字；Lock是个接口。
2. synchronized 无法判断释放获取到锁；Lock可以知道有没有成功获取锁。
3. synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而lock需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
4. synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
5. synchronized可重入，不可中断，非公平；Lock可重入，可判断，可公平

### synchronized和ReentrantLock的区别
答：
1. synchronized是关键字；ReentrantLock是类。
2. synchronized 不需要手动获取锁和释放锁；ReentrantLock必须手动获取与释放锁。
3. synchronized 可以修饰类、方法、变量等； ReentrantLock 只适用于代码块锁。
4. ReentrantLock可以对获取锁的等待时间进行设置；synchronized不行。
5. synchronized控制等待和唤醒是通过wait(),notify(),notifyAll();ReentrantLock控制等待和唤醒是通过await(),singnal(),singnalAll().

### AQS，基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍
答：AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

### CyclicBarrier 和 CountDownLatch 的区别
答：CyclicBarrier和CountDownLatch 都位于java.util.concurrent 这个包下。
区别：

| CyclicBarrier                                                | CountDownLatch                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 加计数方式                                                   | 减计数方式                                                   |
| 计数达到指定值时释放所有等待线程                             | 计算为0时释放所有等待的线程                                  |
| 计数达到指定值时，计数置为0重新开始                          | 计数为0时，无法重置                                          |
| 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 | 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 |
| 可重复利用                                                   | 不可重复利用                                                 |



### JUC原子类
答：Atomic 原子类:atomic 是指一个操作是不可中断的具有原子操作特征的类。
![image](https://img2018.cnblogs.com/blog/687624/201908/687624-20190807151234004-748322976.png)


### 两个线程读，一个线程写，如何实现，不用锁可以吗？
答：

### 线程池作用、参数、有几种
答：
线程池作用：
1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

参数：（前三个最重要）
1. corePoolSize：（核心线程池大小）核心线程数定义了最小可以同时运行的线程数量。
2. maximumPoolSize：最大核心线程池大小。
3. workQueue：阻塞队列，当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
4. keepAliveTime：超时了没人调用就会释放，当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。
5. unit：keepAliveTime 参数的时间单位。
6. threadFactory：线程工厂，创建新线程的时候会用到。
7. RejectedExecutionHandler：拒绝策略（饱和策略），

### Executor
答：

### workQueue
答：

### 拒绝策略有几种？
答：如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略。
1. ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出 RejectedExecutionException异常。
2. ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务（调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。）
3. ThreadPoolExecutor.DiscardPolicy： 丢弃任务，但是不抛出异常。
4. ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行新任务。 （此策略将丢弃最早的未处理的任务请求）。

### 线程池工作原理
答：
提交一个任务到线程池中，线程池的处理流程如下：

1、判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。

2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。

3、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

### 几种常见线程池实现
答： 
- newCachedThreadPool

```
创建一个可缓存线程池，如果线程池长度超过处理需要，可
以灵活回收空闲线程，若无可回收，则新建线程。
```

- newFixedThreadPool

```
创建一个定长线程池，可控制线程最大并发数，超出的线程
会在队列中等待
```

- newScheduledThreadPool

```
创建一个定长线程池，支持定时及周期性任务执行。
```

- newSingleThreadExecutor

```
创建一个单线程化的线程池，它只会用唯一的工作线程来执
行任务，保证所有任务按照指定顺序（FIFO,LIFO,优先级）执行
```

### Java中如何正常终止线程？
答：
1. 使用volatile标志位
2. 使用interrupt()中断的方式，注意使用interrupt()方法中断正在运行中的线程只会修改中断状态位，可以通过isInterrupted()判断。如果使用interrupt()方法中断阻塞中的线程，那么就会抛出InterruptedException异常，可以通过catch捕获异常，然后进行处理后终止线程。有些情况，我们不能判断线程的状态，所以使用interrupt()方法时一定要慎重考虑。

注意：在Thread类中有两个方法可以判断线程是否通过interrupt方法被终止。一个是静态的方法interrupted（），一个是非静态的方法isInterrupted（），这两个方法的区别是interrupted用来判断当前线是否被中断，而isInterrupted可以用来判断其他线程是否被中断。

### 主线程可以捕获子线程抛出的异常吗？
答： 正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。 如果想要在主线程中捕获子线程的异常，我们需要使用ExecutorService，同时做一些修改。（如果每一个线程的异常处理相同，我们可以用如下的方式进行处理，使用Thread的静态方法。）

### 多线程个数？
答：
- 针对IO密集型的，最佳线程数一般会大于cpu核心数很多倍。一般是io设备延时除以cpu处理延时，得到一个倍数，我的经验数值是20--50倍*cpu核心数，具体数值也是要以jvm图形线程监控显示繁忙情况为依据。保证线程空闲可以衔接上。（阻塞耗时w一般都是计算耗时几倍c，假设阻塞耗时=计算耗时的情况下，Nthreads=Ncpu *(1+1)=2Ncpu,所以这种情况下，建议考虑2倍的CPU核心数做为线程数）
- CPU密集型：最佳线程数等于cpu核心数或稍微小于cpu核心数。具体数值要以jvm图形线程监控显示繁忙情况为依据。