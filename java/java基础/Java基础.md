### 常用的索引结构
答：哈希结构、二叉搜索树、红黑树、B树、B+树

### B+树应用
答：MySql、Innodb、MyISAM

### JVM、JRE、JDK
答：
- JVM：java虚拟机，是运行java字节码的虚拟机；
- JRE：java运行时环境，包括JVM、java类库、java命令以及其它一些基础构件
- JDK: java开发工具包，包括JRE、编译器和其它工具


### java和c++的区别
答：
- 都是面向对象的语言，都支持封装、继承、多态
- java不提供指针访问内存，程序内存更加安全
- java支持类的单继承，c++支持多继承
- java有自动内存管理垃圾回收机制，不需要程序员手动释放内存
- 在 C 语言中，字符串或字符数组最后都会有一个额外的字符'\0'来表示结束。但是，Java 语言中没有结束符这一概念。

### Java三大特性（封装、继承、多态）的含义
答：
- 封装：把一个对象的属性封装在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些可以被外界访问的方法来操作属性。
- 继承：子类继承父类，1）子类拥有父类的所有属性和方法（包括私有属性和方法，私有只是拥有，不能访问）；2）子类可以拥有自己的属性和方法（即扩展）；3）子类可以用自己的方式实现父类
- 多态：一个对象拥有多种状态，允许不同类的对象对同一消息做出响应，具体表现为父类引用指向子类的实例（多态不能调用“只在子类存在但在父类不存在”的方法；如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。）

### Java权限：public，protected，private
答：
![image](https://img-blog.csdnimg.cn/20190428102058656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvbnN0Xw==,size_16,color_FFFFFF,t_70)

### Java中类修饰符、成员变量修饰符、方法修饰符的种类与区别
答：
- 类修饰符
1. public，将一个类声明为公共类，他可以被任何对象访问，一个程序的主类必须是公共类。
2. abstract，将一个类声明为抽象类，没有实现的方法，需要子类提供方法实现。
3. final，将一个类生命为最终（即非继承类），表示他不能被其他类继承。
4. friendly，默认的修饰符，只有在相同包中的对象才能使用这样的类。
- 成员变量修饰符
1. public，指定该变量为公共的，他可以被任何对象的方法访问。
2. private，指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。
3. protected，指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。
4. friendly ，在同一个包中的类可以访问，其他包中的类不能访问。
5. final，最终修饰符，指定此变量的值不能变。
6. static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。
7. transient（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。
8. volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改。
- 方法修饰符
1. public，
2. private（私有控制符），指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类）
3. protected（保护访问控制符），指定该方法可以被它的类和子类进行访问。
4. final，指定该方法不能被重载。
5. static，指定不需要实例化就可以激活的一个方法。
6. synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。
7. native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。

### 什么是内存泄漏？
答：内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。

### Java中存在内存泄漏吗？
答：Java中存在内存泄漏的情况，
1）长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露。（检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。

如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。）

2）当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露

### RuntimeException有哪些，提到了空指针异常，问怎么避免空指针异常
答：
常见的RuntimeException类型的异常主要有以下几种。
-  ArithmeticException：数学计算异常。
-  NullPointerException：空指针异常。
-  NegativeArraySizeException：负数组长度异常。
-  ArrayOutOfBoundsException：数组索引越界异常。
-  ClassNotFoundException：类文件未找到异常。
-  ClassCastException：类型强制转换异常。
-  SecurityException：违背安全原则异常。

（其他非RuntimeException类型的常见异常主要有以下几种。
-  NoSuchMethodException：方法未找到异常。
-  IOException：输入输出异常。
-  EOFException：文件已结束异常。
-  FileNotFoundException：文件未找到异常。
-  NumberFormatException：字符串转换为数字异常。
-  SQLException：操作数据库异常）

#### Java避免空指针异常
答： 
1. 从已知的String对象中调用equals()和equalsIgnoreCase()方法，而非未知对象。
2. 当valueOf()和toString()返回相同的结果时，宁愿使用前者。
3. 使用null安全的方法和库 有很多开源库已经为您做了繁重的空指针检查工作。
4. 避免从方法中返回空指针，而是返回空collection或者空数组。
5. 使用annotation@NotNull 和 @Nullable
6. 避免你的代码中不必要的自动包装和自动拆包。
7. 遵从Contract并定义合理的默认值。
8. 定义数据库中的字段是否可为空。
9. 使用空对象模式（Null Object Pattern）。

### 为什么java语言"编译与解释"并存
答：所谓编译型语言指的是编译器将源码编译完成后再执行，所谓解释型语言指的是解释器逐行解释代码并执行。java是首先将源代码编译成字节码，再将字节码逐行解释执行，所以说java语言"编译与解释"并存

### 字符型常量和字符串常量的区别
答：
- 字符型常量由单引号修饰，含一个字符；字符串常量由双引号修饰，含若干字符
- 字符型常量相当于整型值（Ascll）,可以参与表达式运算；字符串常量代表地址值（字符串在内存中的位置）
- 字符常量占2个字节；字符串常量占若干字节

### 标识符和关键字的区别
答：标识符就是名字，关键字是特殊的标识符（new、int、class等等）

### continue、break、return的区别
答：
- continue跳出当前循环，继续执行下一次循环
- break跳出整个循环体，继续执行循环下面的语句
- return跳出方法体，结束执行

### java泛型了解吗？什么是类型擦除？介绍一下通配符
答：
- java泛型：JDK5引入的一个新特性，提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质上是参数化类型，也就是说所操作的数据类型被指定为一个参数。（泛型一般有三种，泛型类、泛型接口、泛型方法）
- 类型擦除：java在编译期间，所有的泛型信息都会被擦掉
- 常用的通配符：T、E、K、V、?
- ?: 表示不确定的java类型
- T（type）: 表示具体的的java类型
- K、V：代表java键值的key、value
- E(element)：代表Element

### java Object类
答：equals、clone、toString、hashCode、finalize、wait、notify、notifyAll

### ==和equals的区别
答：
- ==，对于基本数据类型，比较的是值；对于引用数据类型，比较的是地址
- equals，一般比较的是地址，若重写了（eg:String），比较的一般是值

### hashcode和equals的区别
答：两个对象的hashcode相同，equals不一定相同；两个对象的equals相同，hashcode一定相同。
- 所谓hashcode,用来获取哈希码，也称散列码，实际上返回的是int整数，目的是确定对象在哈希表中的索引位置
- 为什么equals重写，hashcode一定要重写？答：两个对象相同，它们的hashcode一定相同，但是两个对象的hashcode相同，它们不一定相同。所以重写了equals，hashcode也要重写。(如果我们将对象的equals方法重写而不重写hashcode，当我们再次new一个新的对象的时候，equals方法返回的是true，但是hashCode方法返回的就不一样了，如果需要将这些对象存储到集合中（比如：Set，Map ...）的时候就违背了原有集合的原则)
- 为什么两个对象的hashcode相同，它们也不一定相等？答：hashcode所使用的杂凑算法，可能让多个不同的对象返回相同的杂凑值。
- hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。



### 基本数据类型，对应的包装类型
答：
- 基本数据类型：byte、char、short、int、long、float、double、boolean(逻辑上占一位)
- 对应的包装类型：Byte、Character、Short、Integer、Long、Float、Double、Boolean

### 自动拆装箱
答：
- 拆箱：将包装类型转化为基本数据类型
- 装箱：将基本数据类型转化为对应的包装类型

### 8中基本类型的包装类和常量池
答：
- Java基本数据类型的包装类大部分使用到了常量池技术（Byte、Short、Integer、Long、Character、Boolean）,前四种在[-128，127]区间，Character在[0,127]之间，Boolean直接返回True/False
- Float、Double没有用到常量池技术


### 重载和重写
答：
- 重载：发生在同一个类中，方法名相同，参数列表不同（发生在编译期）
- 重写：子类重写父类的方法，外部不变，内部逻辑变（发生在运行期）

### Java类初始化顺序
答：

### 浅拷贝和深拷贝
答：
- 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝
- 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容

### 面向对象和面向过程的区别
答：
- 面向过程：面向过程性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是重要的因素。但是，面向过程没有面向对象易维护、易复用、易扩展。
- 面向对象：面向对象易维护、易复用、易扩展。由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。但是，面向对象性能比面向过程低。

### 构造器 Constructor 是否可被 override?
答：Constructor 不能被override（重写）,重写的前提是继承，因为构造器不能被继承，所以无谈重写，但是可以overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

### 成员变量与局部变量的区别
答：
1. 从语法形式上看:成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被 final 所修饰。
2. 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

### 对象实体与对象引用有何不同?
答：
通过new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。

### 对象的相等与指向他们的引用相等,两者有什么不同?
答：对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

### 在一个静态方法内调用一个非静态成员为什么是非法的?
答：由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

###  静态方法和实例方法区别
答：
1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。

### Java 序列化中如果有些字段不想进行序列化，怎么办？
答：使用 transient 关键字修饰。（transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。）

### Final、static、this、super关键字
答：
- final：修饰的类不能被继承；修饰的方法不能被重写；final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象
- static：修饰成员变量和成员方法；静态代码块；静态内部类（static修饰类的话只能修饰内部类）；静态导包(用来导入类中的静态资源，1.5之后的新特性）
- this：用于引用类的当前实例。
- super：用于从子类访问父类的变量和方法。
- 注意：this、super不能用在static方法中，因为：this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。

### final在java中有何作用？
答：final，修饰变量，变量不可变；修饰方法，方法不可重写；修饰类，类不能被继承。

### final、finally、finalize区别
答：
- finally作为异常处理的一部分，它只能用在try/catch语句中，表示总是会执行。
- finalize

### string操作字符串有哪些类，他们之间有何区别？
答：有string，stringbuffer，stringbuilder。string的底层是不可变字符数组，不能修改；stringbuffer和stringbuilder的底层是可变字符数组，可以修改。stringbuffer是线程安全。stringbuilder线程不安全，但是效率更高。

### String str="i"和String str=new String("i")区别
答：前者在常量池中创建了一个对象，后者可能创建了两个对象。

### string类的常用方法
答：indexof(),charAt(),replace(),trim(),spilt(),getBytes(),length(),toUpperCase(),toLowerCase(),substring(),equals().

### 抽象类与普通类的区别
答：
1. 抽象类不能进行实例化，普通类可以
2. 抽象类不一定要有抽象方法，普通类一定没有抽象方法

### 抽象类和接口的区别
答：
1. 抽象类用extends来继承，接口用implements来实现
2. 抽象类可以有main方法，构造方法，接口没有
3. 抽象类中的方法可以是任意类型，接口中只能是public类型
4. 一个类只能继承一个抽象类，但是可以实现多个接口

### java i/o流分为几种？
答：分为输入流，输出流。或者说字节流，字符流。

### java中BIO、NIO、AIO的区别
答：
- BIO是同步阻塞式IO，是传统IO，任务被阻塞在一个线程中直到其完成，特点是操作简单，使用方便，并发处理能力低，适合于低负载低并发
- NIO是同步非阻塞式IO，是BIO的升级，客户端和服务器通过通道通信，实现了多路复用，适合于高负载高并发
- AIO是异步非阻塞式IO，操作基于事件和回调机制。

### Files的常用方法
答：exists(),createFile(),createDictory(),delete(),copy(),move(),read(),write(),size()

### ArrayList常用方法
答：add(object value),add(int index, Object obj),remove(index),remove(value),size(),set(index,value),
get(index),clear()

### LinkedList常用方法
答：