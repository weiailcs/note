### Java8新特性
答：
1. lambda表达式：允许把函数作为参数传递到方法（简化匿名内部类代码）。
2. 方法引用：可以引用已有类或对象的方法和构造方法，进一步简化lambda表达式。
3. 函数式接口：有且仅有一个抽象方法
4. 接口默认方法：接口可以定义default修饰的默认方法。

### Java中怎么确定唯一类？
答：类加载器 + 类路径

### 基本数据类型和包装类型的区别
答：
1. 初始值不同 ，一般基本数据类型为0，包装类型存储为null；
2. 包装类型可以当做对象使用，提供了一系列操作方法，而基本数据类型不可以；
3. 基本数据类型存在栈中，包装类型存在堆中
（4. 基本数据类型直接赋值使用就好，而包装类型是在集合如collction Map时会使用；5. 基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间；）

### 构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？
答：父类静态方法和代码块、子类静态方法和代码块、父类非静态方法和代码块、父类构造方法、子类非静态方法和代码块、子类构造方法。

### 接口和抽象类的相同点
答：均不能实例化；接口的实现类需要实现接口中的相应方法才能实例化，抽象类的子类需实现抽象类的相应方法才能实例化。

### 为什么Java不支持多继承？
答：
1. 为了让程序更加清晰和易于维护，比如说，如果支持多继承，类C继承了类A和类B，假设A和B均有f()方法，那么类C调用f()方法时就会产生二义性。Java语言通过实现多接口间接支持多继承，接口中由于只含有方法定义，不能有方法的实现，类C继承接口A和接口B时即使它们都有方法f()，也不能直接调用方法，需要实现具体的方法才能调用，不会产生二义性。
2. 多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。

### 数组为什么这么快？
答：索引  arr[n] = 100 + (4 * n + 1)

### 假设有100w数据，怎么用ArrayList？
答：直接设置100w大小的ArrayList，防止自动扩容。

### BIO、NIO和AIO的区别
答：
BIO：传统IO，同步阻塞式IO，方法会阻塞在同一个线程中，直到其完成，特点是操作简单，使用方便，并发处理能力低，使用于低负载、低并发。

NIO：同步非阻塞式IO，传统IO的升级，客户端和服务器通过通道通信，实现了多路复用。适用于高负载高并发。

AIO：异步非阻塞式IO，NIO的升级，异步IO的操作基于事件和回调机制。

### Files常用方法
答：Files.exists():检测文件路径是否存在；Files.creatFile(): 创建文件

Files.creatDirecity():创建文件夹； Files.delete();  Files.copy();  Files.move();

Files.read();  Files.write();  Files.size()


### Hashtable为什么被弃用了？
答：
1. 效率低，没有遵循驼峰命名法
2. 继承了被弃用的Dictionary,而Dictionary已经被弃用，其子类也当然被弃用。

### 如何实现数组和List的转换？
答：数组 -> 链表 ： Arrays.asList(array)  ; 
链表 -> 数组： List list = new ArrayList(); list.toArray();

### ArrayList 和 Vector 的区别
答：ArrayList不安全，但效率更高，扩容为原来的1.5倍；Vector线程安全，效率低，扩容为原来的两倍。

### 在Queue中poll()和remove()的区别
答：poll()和remove()都是返回删除一个元素,poll()失败会返回null,remove()失败会抛出NoSuchElementException异常。

### Integer 和 ListInteger 区别
答：
1. Integer可以遍历Set和List，ListInteger只能遍历List
2. Integer只能单向遍历，ListInteger可以双向遍历
3. ListInteger实现了Integer接口，提供了更多的方法，eg:添加一个元素，替换一个元素。

### 怎么确保一个集合不能被修改？
答： 可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合。

### 守护线程
答：守护线程，是个服务线程（服务其它的线程）。（Java线程一般包括守护线程和用户线程）

### run() 和 start()区别
答：run()只是线程中的一个普通方法，start()是启动线程的方法。run()可以重复调用，而start()只能调用一次。

### 线程池中 submit() 和 execute() 方法有什么区别？
答：execute()：只能执行 Runnable 类型的任务。
submit()：可以执行 Runnable 和 Callable 类型的任务。
（Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。）

### 怎么防止死锁？
答：进程启动拒绝和资源分配拒绝，设置超时时间，超时则退出。

### ThreadLocal使用场景
答： ThreadLocal 的经典使用场景是数据库连接和 session 管理等。

###  说一下atomic 的原理
答：atomic主要通过CAS、volatile和native方法来保证原子操作。

### 什么是序列化？什么情况下会用到序列化？
答：序列化就是将对象转化为字节码。Java序列化的作用是保存各种对象在内存中的状态，并且可以把保存的状态读出来。

应用场景：
1. 想把的内存中的对象状态保存到一个文件中或者数据库中时候；
2. 想用套接字在网络上传送对象的时候；
3. 想通过 RMI（远程方法调用）传输对象的时候。

### 动态代理是什么？有哪些应用？
答：动态代理是运行时动态生成代理类。

应用：spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java 注解对象获取
等。

### session 和 cookie 有什么区别？
答：
1. 存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。
2. 安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。
3. 容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。
4. 存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。

### 如果客户端禁止 cookie 能实现 session 还能用吗？
答：可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加sessionid 的方式保证 session 能正常使用。

### try-catch-finally 中哪个部分可以省略？
答：try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。

### 出现在Java程序中的finally代码块是否一定会执行？
答：一般情况下会执行，但是1. 当程序进入try语句块之前就出现异常时会直接结束 2. 当程序在try块中强制退出时，如：System.exit(0),也不会执行finally块中的代码。

### JIT即时编译
答：当代码的执行次数超过一定的阈值，会将Java字节码转化为本地代码，提高速度。

### 你能保证 GC 执行吗？
答：不能，虽然有System.gc()和Runtime.gc(),但是他们只是通知jvmGC，但是没有保证GC的执行。

### 都说syn为重量级锁，那么到底重在哪里？
答：JVM偷懒把任何跟线程有关的操作全部交给操作系统去做，（例如调度锁的同步直接交给操作系统去执行，而在操作系统中要执行先要入队，另外操作系统启动一个线程时需要消耗很多资源，消耗资源比较重，重就重在这里。）

### Java基本类型和引用类型的区别，String为什么不是基本数据类型？
答：基础类型只表示简单的字符或数字，引用类型可以是任何复杂的数据结构，而且包括方法。

### object类的equals()方法和clone()方法是做什么的，以及应用场景
答：equals()比较两个对象的引用地址是否相同； clone()：对对象进行拷贝

### volatile不保证并发有序性

### 简述自适应自旋锁
答：自旋次数不再是人为规定，而是由上一次获取锁的自旋时间来决定

### 简述锁粗化
答：扩大加锁范围，避免反复的加锁和解锁

### 简述锁消除
答：在编译时，Java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。

### ReentrantLock中trylock() 和 lock() 区别
答： lock() : 阻塞加锁  trylock() : 非阻塞加锁

### 