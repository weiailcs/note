#### JVM常见参数
答：
- -Xmn:设置新生堆大小
- -Xms:设置最小堆空间
- -Xmx:设置最大堆空间

### 判断对象死亡
答：
1. 引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。（所谓对象之间的相互引用问题，如下面代码所示：除了对象objA和objB相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知GC回收器回收他们。）
2. 可达性分析法：通过一系列的称为 “GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots没有任何引用链相连的话，则证明此对象是不可用的。

### 可作为 GC Roots 的对象包括下面几种:
1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 本地方法栈(Native 方法)中引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象

### 不可达的对象并非“非死不可”
答：即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。
被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

### 强引用、软引用、弱引用、虚引用
答：
- 强引用：如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出 OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
- 软引用：如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。（软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。）
- 弱引用：如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。（弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。）
- 虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。

### Java应用场景
答：

### 如何判断一个常量是废弃常量？
答：运行时常量池主要回收的是废弃的常量和无用的类。那么，我们如何判断一个常量是废弃常量呢？废弃常量指的是常量对象没有在任何地方被引用。


### 如何判断一个类是无用的类
答：类需要同时满足下面 3 个条件才能算是 “无用的类”：
1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法
答：标记-清除算法、复制算法、标记-整理算法、分代收集算法

### 查看GC状态的命令
答：jstat [Options] vmid [interval] [count]

参数说明：
- Options，选项，我们一般使用 -gcutil 查看gc情况
- vmid，VM的进程号，即当前运行的java进程号
- interval，间隔时间，单位为秒或者毫秒
- count，打印次数，如果缺省则打印无数次

### 垃圾收集器
答：
- CMS 收集器：
- G1 收集器：
- ![image](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png)

### CMS收集器的流程
答：CMS(Concurrent Mark Sweep)收集器是一种获取最短回收停顿时间为目标的收集器。
CMS收集器是一种基于"标记-清除"算法实现的收集器，整个过程分为四步

```
1.初始标记(CMS initial mark)
2.并发标记(CMS concurrent mark)
3.重新标记 (CMS remark)
4.并发清除 (CMS concurrent sweep)

```
- 初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快
- 并发标记就是进行GC Roots Tracing 的过程(从GC Roots开始找到它能引用的所有其它对象)
- 重新标记阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
- 并发清理（CMS concurrent sweep）：可以和用户线程并发执行，清理在重新标记中被标记为可回收的对象。

注意：初始标记和重新标记都会导致STW。

STW（stop the world）:暂停用户线程，让GC更有效率。

总结：由于整个过程耗时最长的并发标记和并发清除都可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。优点：并发收集、低停顿。

### （CMS 收集器的缺点）
答：
1. CMS收集器对CPU非常敏感。其实面向并发设计的程序都对CPU比较敏感，在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程(或者说CPU资源)而导致应用程序变慢，总吞吐量降低。CMS默认启动的回收线程数是(CPU数量+3)/4,也就是当CPU在4个以上时，并发回收时，垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU数量不足4个时，CMS对用户程序的影响就可能变的很大。如果CPU负载本来就很大，还要分出一半的运行能力去执行收集器线程，就可能导致用户程序的执行能力下降50%
2. CMS收集器无法处理浮动垃圾。可能出现"Concurrent Mode Failure"失败而导致另一次Full GC。由于CMS并发清理阶段用户线程还在运行着，伴随着程序的运行自然就还会有新的垃圾不断产生，这一部分产生的垃圾，CMS无法在当次收集中处理掉他们，只要留待下一次GC再进行处理。这一部分产生的垃圾成为"浮动垃圾"。也是由于在垃圾收集阶段用户线程还要继续运行，那也就还需要预留足够的内存空间给用户线程使用。因此CMS收集器不能像其他收集器那样，等到老年代被填满后再进行垃圾回收。需要预留一部分空间供并发收集时的程序运行使用。
3. 由于CMS采用"标记-清理"算法实现，所以当垃圾收集后，会产生大量的内存碎片。空间碎片过多，当程序运行需要分配大对象时，由于找不到连续的内存空间，而不得不提前触发一次Full GC.CMS采用了-XX:+UseCMSCompactAtFullCollection开关参数，用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。内存碎片的整理是无法并发执行的，空间碎片问题没有了，但是随之而来的停顿时间变长了。因此，虚拟机设计者还提供了一个参数：-XX:CMSFullGCsBeforeCompaction来进行设置执行多少次不压缩的Full GC后进行一次带压缩的(默认是0.标识每次进入Full GC后都会带有一次内存压缩)

空间分配担保：

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。当大量对象在Minor GC后仍然存活，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接进入老年代。如果老年代判断到剩余空间不足（根据以往每一次回收晋升到老年代对象空间的平均值作为经验值），则进行一次Full GC。

### G1收集器的流程
答：
1. 初始标记：这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象。
2. 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长。当并发标记完成后，开始最终标记(Final Marking )阶段
3. 最终标记:标记那些在并发标记阶段发生变化的对象，将被回收。
4. 筛选回收:首先对各个Regin的回收价值和成本进行排序，然后根据用户所期待的GC停顿时间指定回收计划，回收一部分Region。

### CMS收集器和G1收集器的区别
答：
1. 使用范围不一样，CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用。
2. STW的时间，CMS收集器以最小的停顿时间为目标的收集器；G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）。
3. 垃圾碎片，CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片；G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。
4. 垃圾回收的过程不一样。

### 内存管理(对象创建、布局、访问定位)
答：
对象的内存布局：
对象在内存中存储的布局可分为3部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
- 对象头：对象头由类型指针、标记字段和数组长度(只有数组对象才有)，标记字段用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那么对象头还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组大小。
- 实例数据：实例数据部分是对象真正存储的有效信息。
- 对象填充：因为自动内存管理系统要求对象的大小必须是8字节的整数倍，才有对象填充的说法。

对象的访问定位：Java程序需要通过栈上的reference数据来操作堆上的具体对象。reference类型存放的是对象的引用，但是具体怎么样访问对象取决于虚拟机实现而定。目前主流的访问方式有“使用句柄”和“直接指针”两种。

### 堆内存分配策略
答：
1. 对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次MinorGC。
2. 大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。
4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。

### 查看java虚拟机内存占用？
答：
1. jps：查看本地正在运行的java进程和进程ID（pid）
2. jinfo pid：查看指定pid的所有JVM信息
```
1）jinfo -flags pid 查询虚拟机运行参数信息。
2）jinfo -flag name pid，查询具体参数信息，如jinfo -flag UseSerialGC 42324，查看是否启用UseSerialGC
```
3. jmap：打印内存映射，制作堆dump文件
```
1）jmap -heap pid：输出堆内存设置和使用情况（JDK11使用jhsdb jmap --heap --pid pid）
2）jmap -histo pid：输出heap的直方图，包括类名，对象数量，对象占用大小
3）jmap -histo:live pid：同上，只输出存活对象信息
4）jmap -clstats pid：输出加载类信息
5）jmap -help：jmap命令帮助信息
```
4. jstat：Java虚拟机统计工具，可以用于监视JVM各种堆和非堆内存大小和使用量
```
1）jstat -class pid：输出加载类的数量及所占空间信息。
2）jstat -gc pid：输出gc信息，包括gc次数和时间，内存使用状况（可带时间和显示条目参数）
```
5. jconsole：简易的可视化控制台

### GC调优原则
答：多数的 Java 应用不需要在服务器上进行 GC 优化； 多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题； 在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）； 减少创建对象的数量； 减少使用全局变量和大对象； GC 优化是到最后不得已才采用的手段； 在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多。

### GC 调优目的
答：
1. 将转移到老年代的对象数量降低到最小； 
2. 减少 GC 的执行时间。

### GC 调优策略
答：
策略 1：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

策略 2：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收来说简直就是噩梦）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。

策略 3：合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。

策略 4：设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。

策略5： 如果满足 MinorGC 执行时间不到50ms； Minor GC 执行不频繁，约10秒一次； Full GC 执行时间不到1s； Full GC 执行频率不算频繁，不低于10分钟1次。这一指标，则一般不需要进行 GC 优化