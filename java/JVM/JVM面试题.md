### Serial 与 Parallel GC之间的不同之处？
答：Serial执行GC的时候只有一个线程，而Parallel收集器用多个线程。 （Serial 与 Parallel 在GC执行的时候都会引起STW）

### JVM选项 -XX:+UseCompressedOops有什么作用？为什么要使用？
答：进行压缩，节约内存，当你将你的应用从32位的 JVM 迁移到64位的 JVM 时，由于对象的指针从32变为了64位，因此堆内存会突然增加。通过压缩oop可以节省一定内存。

### 打破双亲委派模型
答：继承ClassLoader 重写findClass()方法和loadClass()

### jvm内存模型为什么要区分堆和栈？
答：
1. 方便共享通信：堆是线程共有，而栈是线程私有；
2. 方便管理：堆中的生命周期长，而栈的生命周期短

### 你们项目如何排查JVM问题
答：
对于还在正常运行的系统：

1. 可以通过jmap来查看JVM中各个区域的使用情况
2. 可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现死锁
3. 可以通过jstat来查看垃圾回收的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了
4. 通过各个命令的结果，或者jvisualvm等工具来进行分析
5. 首先，初步猜测频繁发送fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入老年代，尝试加大年轻代的大小，如果改完之后，fullgc减少，则证明修改有效
6. 同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存

对于以经发生了OOM的系统：

1. 一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件（-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath = /usr/local/base）
2. 我们可以利用jvisualvm等工具来分析dump文件
3. 根据dump文件找到异常的实例对象，和异常的线程（占用CPU高），定位到具体的代码
4. 然后在进行详细的分析和调试