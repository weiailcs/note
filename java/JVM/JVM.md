### JVM体系结构
答：
1. 类装载器（ClassLoader）（用来装载.class文件）
2. 执行引擎（执行字节码，或者执行本地方法）
3. 运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）

### java内存区域
![image](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/ff96fed0e2a354bb16bbc84dcedf503a.png)

### Java虚拟机运行流程
答：①Java源文件—->编译器（工具）—->字节码文件②字节码文件—->JVM（工具）—->机器码

### java虚拟机的核心设计思想
答：Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器，它可以从程序和API中装载class文件。Java API中只有程序执行时需要的那些类才会被装载。字节码由执行引擎来执行。

# 堆
目的：存放对象实例。几乎所有的对象实例以及数组在这里分配空间。可以分为4个区域，Eden区，s0区（from），s1（to）区，ternet区。默认比例，Eden:s0:s1=8:1:1
- 一般对象首先会在Eden区分配内存，当Eden区满了之后会触发minorGC，存活的对象年龄+1，当年龄达到了阈值（一般是15，可以自己设置），会进入老年代。
- 从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。
- 在 JDK 1.7 版本及JDK1.7版本之前，堆通常被分为新生代、老生代、永生代。JDK1.8版本之后方法区（HotSpot的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存
- 线程不安全

### 堆细分的目的
答：更好地回收内存，或者更快地分配内存。

### minorGC和fullGC
答：
- minorGC，新生代GC，当Eden区满了之后会触发，速度快
- fullGC，老年代GC，速度一般比minorGC慢10倍以上

### 如何减少full gc的次数？
答：

### jvm堆内存常用参数
答：
- -xms  堆内存初始化大小
- -xmx  堆内存最大允许大小
![image](https://img-blog.csdnimg.cn/20200916231634199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjA1OTkwNw==,size_16,color_FFFFFF,t_70#pic_center)

### 垃圾回收算法
答：
- 标记-清除算法：将所有要回收的对象标记出来，统一回收。缺点：容易产生内存碎片
- 复制算法：将内存分为大小相等的两块，每次只使用其中一块，当这块内存用完，将存活的对象复制到另一块内存上。缺点：需要两倍的内存空间
- 标记-整理算法：将所有存活的对象向一端移动，清除掉边界以外的内存。缺点：效率没有标记-清除算法高。优点：解决了碎片问题和空间问题
- 分代收集算法：上面三种算法的整合，新生代（大批对象死去，少量对象存活），采用复制算法；老年代（对象存活率高），采用标记-清除算法或者标记整理算法。


# 栈
java内存可以粗略的分为堆内存和栈内存，栈内存指的是虚拟机栈中的局部变量表部分，局部变量表存储的是编译期可知的各种数据类型、对象引用

# 程序计数器
有两个作用，
- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
- 用于记录线程的执行位置，便于线程切换

### 程序计数器为什么是私有的?
答：为了线程切换后能恢复到正确的执行位置

# 虚拟机栈
由一个一个的栈帧组成，每个栈帧包括局部变量表，操作数栈、动态链接、方法出口信息

# 本地方法栈
和虚拟机栈一样，由一个个栈帧组成。区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务

### 方法区
它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 方法区是否需要gc
答：需要，但是很少，主要是针对 废弃常量的回收（常量池的回收）和对无用类的回收（类的卸载）
- 废弃常量：当一个常量对象不再任何地方被引用的时候，则被标记为废弃常量
- 无用的类：1、该类所有的实例都已经被回收，也就是说Java堆中不存在该类的任何实例；2、加载该类的ClassLoader已经被回收；
3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 直接内存
直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。

### 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
答：
1. 整个永久代有一个JVM本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。（你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。）
2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了,而由系统的实际可用空间来控制，这样能加载的类就更多了。
3. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西,合并之后就没有必要额外的设置这么一个永久代的地方了。

###  运行时常量池
答：运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

### Java中的常量池
答：静态常量池和运行时常量池。
- 静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。
- 运行时常量池，jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。

### 对象的创建过程
答：
1. new一个对象时，在堆内存中开辟一块空间
2. 给开辟的空间分配一个地址
3. 把对象的所有非静态成员加载到所开辟的空间下
4. 所有的非静态成员加载完成之后，对所有非静态成员变量进行默认初始化
5. 所有非静态成员变量默认初始化完成之后，调用构造函数
6. 在构造函数入栈执行时，分为两部分：先执行构造函数中的隐式三步，

        ====①执行super()语句   ②对开辟空间下的所有非静态成员变量进行显示初始化  ③执行构造代码块====

再执行构造函数中书写的代码。
7. 在整个构造函数执行完并弹栈后，把空间分配的地址赋给引用对象。

注：  super语句，可能出现以下三种情况:

1）构造方法体的第一行是this()语句，则不会执行隐式三步，而是调用this()语句所对应的的构造方法，最终肯定会有第一行不是this语句的构造方法。

2）构造方法体的第一行是super()语句，则调用相应的父类的构造方法， 

3）构造方法体的第一行既不是this()语句也不是super()语句，则隐式调用super()，即其父类的默认构造方法，这也是为什么一个父类通常要提供默认构造方法的原因。

注意:多线程使用同一对象时需要注意对象创建时指令重排序的问题

### 为什么要使用多线程呢?
答：
- 从计算机底层来说：线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- 从当代互联网发展趋势来说：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。
- 单核时代： 在单核时代多线程主要是为了提高CPU和IO设备的综合利用率。举个例子：当只有一个线程的时候会导致CPU计算时，IO设备空闲；进行 IO 操作时，CPU空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行IO操作，这样两个的利用率就可以在理想情况下达到 100%了。
- 多核时代: 多核时代多线程主要是为了提高CPU利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU只会一个 CPU 核心被利用到，而创建多个线程就可以让多个CPU核心被利用到，这样就提高了 CPU 的利用率。

### 使用多线程可能带来什么问题?
答：（并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：）内存泄漏、死锁、线程不安全等等。

### 什么是上下文切换?
答：多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。

### JVM小总结
答：
1. Java文件经过编译后变成 .class 字节码文件
2. 字节码文件通过类加载器被搬运到 JVM 虚拟机中
3. 虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行