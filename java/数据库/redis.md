### Redis有哪些数据结构
答：
1. string,redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。
2. hash,是一个Mapmap，指值本身又是一种键值对结构，如 value={{field1,value1},......fieldN,valueN}}  (所有hash的命令都是  h   开头的     hget  、hset 、  hdel 等)
![image](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190621232209365-1000366002.png)
3. list(链表),redis 使用双端链表实现的 List，是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。
![image](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190621233618769-504231907.png)
4. set集合,无序，不可重复，不能通过索引下标获取元素，支持集合间的操作，可以取多个集合取交集、并集、差集
![image](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190622001013515-677922001.png)
5. zset有序集合，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。元素不可重复，但是分数（score）可以重复。（有序集合的命令都是 以  z  开头    zadd 、 zrange、 zscore）
![image](https://img2018.cnblogs.com/blog/1289934/201906/1289934-20190622000959260-539243592.png)

### String类型的底层实现
答：Redis中，默认以SDS作为自己的字符串表示。只有在一些字符串不可能出现变化的地方使用C字符串。

```
struct sdshdr {    
  // 用于记录buf数组中使用的字节的数目
  // 和SDS存储的字符串的长度相等  
	int len;    
  // 用于记录buf数组中没有使用的字节的数目   
	int free;    
  // 字节数组，用于储存字符串
	char buf[];   //buf的大小等于len+free+1，其中多余的1个字节是用来存储’\0’的。
};

```
与其它语言环境中出现的字符串相比，它具有如下显著的特点：
- 可动态扩展内存。sds表示的字符串其内容可以修改，也可以追加。在很多语言中字符串会分为mutable和immutable两种，显然sds属于mutable类型的。
- 二进制安全（Binary Safe）。sds能存储任意二进制数据，而不仅仅是可打印字符。
- 与传统的C语言字符串类型兼容。

使用SDS而不使用c语言的string的好处：

1. 常数复杂度获取字符串长度

```
C语言中:字符串只是简单的字符的数组，当使用strlen获取字符串长度的时候
，内部其实是直接顺序遍历数组的内容，找到对应的’\0’对应的字符，从而计算出字符串的长度。即O(N)。

SDS:只需要访问SDS的len属性就能得到字符串的长度，复杂度为O(1)。


```

2. 杜绝缓冲区溢出

```
Redis是C语言编写的，并没有方便的数据类型来进行内存的分配和释放（C++ 
STL String），必须手动进行内存分配和释放。

对于字符串的拼接、复制等操作，C语言开发者必须确保目标字符串的空间足够
大，不然就会出现溢出的情况。

当使用SDS的API对字符串进行修改的时候，

1.API内部第一步会检测字符串的大小是否满足。
    1.如果空间已经满足要求，那么就像C语言一样操作即可。如果不满足，则拓展buf的空间
2.之后再进行操作。每次操作之后，len和free的值会做相应的修改。
```
```
扩展buf空间策略：
修改之后总长度len<1MB: 总空间为2*len+1;
修改之后总长度len>=1MB: 总空间为len+1MB+1。
换句话说，预分配的空间上限是1MB，尽量为len。

```
3. 减少修改字符串时带来的内存重分配次数

```
Redis主要通过以下两种策略来处理内存问题。

字符串长度增加操作时，进行空间预分配

字符串长度减少操作时，惰性空间释放

当执行字符串长度缩短的操作的时候，SDS并不直接重新分配多出来的字节，而
是修改len和free的值（len相应减小，free相应增大，buf的空间大小不变化）
，避免内存重分配。

SDS也提供直接释放未使用空间的API，在需要的时候，也能真正的释放掉多余的空间。
```

4. 二进制安全

```
C字符串除了末尾之外不能出现空字符，否则会被程序认为是字符串的结尾。这
就使得C字符串只能存储文本数据，而不能保存图像，音频等二进制数据。

使用SDS就不需要依赖控制符，而是用len来指定存储数据的大小，所有的SDS 
API都会以处理二进制的方式来处理SDS的buf的数据。程序不会对buf的数据做
任何限制、过滤或假设，数据写入的时候是什么，读取的时候依然不变。
```

5. 兼容部分C字符串函数

```
SDS的buf的定义（字符串末尾为’\0’)和C字符串完全相同，因此很多的C字符串的操作都是适用于SDS->buf的。比如当buf里面存的是文本字符串的时候，大多数通过调用C语言的函数就可以。
```
总结

| C字符串                                    | SDS                                        |
| ------------------------------------------ | ------------------------------------------ |
| 获取字符串长度的复杂度为O(N)               | 获取字符串长度的复杂度为O(1)               |
| API是不安全的，可能会造成缓冲区溢出        | API是安全的，不会造成缓冲区溢出            |
| 修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多需要执行N次内存重分配 |
| 只能保存文本数据                           | 可以保存文本或者二进制数据                 |
| 可以使用所有库中的函数                     | 可以使用一部分库的函数                     |

[Redis String底层实现](https://blog.csdn.net/pugongying_95/article/details/99718749)

### 使用Redis的好处
答：
1. 速度快，数据存储在内存中，（类似于hashmap）
2. 支持多种数据类型，eg:string,hash,list,set,zset,bitmap
3. 支持事务，操作都是原子性（要么成功，要么失败）

### MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点？
答：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策
略。redis 提供 6 种数据淘汰策略：
- voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-enviction（驱逐）：禁止驱逐数据

### Memcache 与 Redis 的区别都有哪些？
答：
1. redis速度更快。
2. redis支持复杂的数据类型；Memcache支持单一数据类型。
3. redis有部分数据存储在磁盘上，支持数据持久化。

### redis集群原理
答：对于单点故障（master宕机），slave自动提升为master（高可用）；对于单个redis内存不足，使用cluster分片存储。（扩展性）

### redis 集群如何保证一致性
答：客户端向master写数据，master直接更新做出应答，之后更新slave中的数据。（这叫异步）

### Hash字典类型
答：

### Redis渐进式rehash 为什么
答：

### Redis中zset的内部实现跳跃表 为什么
答：

### Redis支持事务吗
答：

### Redis单线程还是多线程，为什么？
答：

### Redis单线程为什么还并发量那么高
答：

### Redis为什么快？
答：

### 缓存穿透以及解决
答：缓存穿透，指缓存和数据库都没有数据，导致所有请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决方案：
- 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
- 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
- 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

### 缓存雪崩以及解决
答：缓存雪崩，指缓存同一时间内大面积失效，此后，所有请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决方案：
- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
- 给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。

### 缓存击穿以及解决
答：指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

解决方案：
- 设置热点数据永远不过期。
- 加互斥锁

### redis内存满了怎么办
答：redis是基于内存的key-value数据库，redis的内存可以通过配置文件配置（通过在Redis安装目录下面的redis.conf配置文件中添加maxmemory 100mb设置内存大小）和通过命令修改（Redis支持运行时通过命令动态修改内存大小，config set maxmemory 100mb）

注：如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存

Redis定义了几种策略用来处理内存用完的情况：
- noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
- allkeys-lru：从所有key中使用LRU算法进行淘汰
- volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰
- allkeys-random：从所有key中随机淘汰数据
- volatile-random：从设置了过期时间的key中随机淘汰
- volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰

注：当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误

使用策略规则：

1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru

2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random

获取当前内存淘汰策略：

```
127.0.0.1:6379> config get maxmemory-policy
```
通过配置文件设置淘汰策略（修改redis.conf文件）：

```
maxmemory-policy allkeys-lru
```
通过命令修改淘汰策略：

```
127.0.0.1:6379> config set maxmemory-policy allkeys-lru
```
LRU算法

LRU算法，least RecentlyUsed，最近最少使用算法。也就是说默认删除最近最少使用的键。

但是一定要注意一点！redis中并不会准确的删除所有键中最近最少使用的键，而是随机抽取5个键，删除这五个键中最近最少使用的键。

### redis过期键的删除策略？
答：
1. 定时删除:在设置键的过期时间的同时，创建一个定时器timer. 让定时器在键的过期时间来临时，立即执行对键的删除操作。
2. 惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
3. 定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

### 缓存更新策略
答：key的过期删除和内存淘汰策略

### 持久化
答：将内存中的数据迁移到硬盘的过程

### Redis持久化的方法
答：Redis 持久化有两种方式，一种是通过特定时间节点形成的快照（RDB持久化），另一种是由日志（AOF持久化）来进行备份管理。

### RDB持久化
答：通过bgsave命令触发，父进程fork()一个子进程，由子进程对数据进行快照生成RDB

优点：是一个紧凑压缩的二进制文件，RDB 恢复数据远远快于 AOF的方式。

缺点：由于每次生成RDB开销较大，非实时持久化，而且持久化期间父进程对数据的修改不会被保存。

### AOF持久化
答：开启后，Redis 每执行一个修改数据的命令，都会把这
个命令添加到 AOF 文件中。

优点：实时持久化。

缺点：AOF文件体积逐渐变大，需要定期执行重写操作来降低文件体积，
加载慢

### AOF重写
答：将最新数据转为写指令存入新的AOF文件，替换旧的aof文件。

### redis主从结构
答：

### redis哨兵
答：哨兵节点进行自主监控主从节点以及其他哨兵节点

### Redis集群
答：

### 集群是如何判断是否有某个节点挂掉（主从复制模式下，主挂了怎么办？）
答：通过哨兵模式可以判断节点是否挂掉，如果主节点挂掉了，slave可以升为master。

### 为什么 Redis 的操作是原子性的，怎么保证原子性的？
答：Redis 的操作之所以是原子性的，是因为 Redis 是单线程的。Redis 本身提供的所有 API 都是原子操作，Redis 中的事务其实是要保证批量操
作的原子性。

多个命令在并发中也是原子性的吗？

不一定， 将 get 和 set 改成单命令操作，incr 。使用 Redis 的事务，或者使用
Redis+Lua==的方式实现.

### 分布式锁作用
答：解决分布式环境下共享资源的同步问题。

### 一致性哈希
答：

### 缓存与数据库双写一致
答：

### 跳表
答：

### 为什么用跳表不用b+树？
答：

### redis分布式锁的实现
答：