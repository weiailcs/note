### 死锁
答：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放

### 产生死锁四个条件
答：
1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### 如何预防线程死锁?
1. 破坏互斥条件 ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
2. 破坏请求与保持条件 ：一次性申请所有的资源。
3. 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
4. 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

### sleep() 方法和 wait() 方法区别和共同点
答：
1. 两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。
2. 两者都可以暂停线程的执行。
3. Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
4. wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(longtimeout)超时后线程会自动苏醒。

### 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用 run() 方法？
答：调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。