### osi七层架构、功能以及代表协议
答：
- 应用层：（为操作系统或网络应用程序提供访问网络的接口）规定了数据的传输协议      代表协议DNS、HTTP、FTP
- 表示层：解决了不同系统之间的通信（eg:加密、解密、压缩、解压缩）  代表协议：Telnet、SNMP
- 会话层：建立一个连接  代表协议：SMTP、DNS
- 传输层：端口与端口之间的通信  代表协议：TCP、UDP
- 网络层：确定计算机的位置  代表协议：IP、ICMP 、ARP
- 数据链路层：规定了0、1分包的形式，确定了网络数据包的形式 
- 物理层：确保了原始数据可以在各种物理媒体上传输   

### TCP 三次握手
答：
![image](https://images2015.cnblogs.com/blog/593345/201702/593345-20170204231325729-1747734402.png)
- 第一次握手：客户端向服务端发送连接请求报文段
- 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答
- 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。

### 为什么要三次握手
答：三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

### 为什么要传回SYN？
答:接收端传回发送端所发送的SYN是【为了告诉发送端，我接收到的信息确实就是你所发送的信号了】。

### 第2次握手传回了SYN，为什么还要传回ACK？
答：接收端传回发送端所发送的SYN是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传ACK则是为了建立并确认从服务端到客户端的通信。

### TCP 四次挥手
答：
![image](https://images2015.cnblogs.com/blog/593345/201702/593345-20170204231344745-1817753534.jpg)
- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

### TCP（传输控制协议）,UDP（用户数据报协议） 协议的区别
答：
1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
    UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5. TCP首部开销20字节;UDP的首部开销小，只有8个字节
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

### TCP 协议如何保证可靠传输
答：
- 校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
- 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
- 拥塞控制： 当网络拥塞时，减少数据的发送。
- ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
- 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### UDP如何保证可靠
答：
1. 添加seq/ack机制，确保数据发送到对端
2. 添加发送和接收缓冲区，主要是用户超时重传。
3. 添加超时重传机制。

详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。


### TCP、UDP、IP报文格式
答：

### TCP粘包和拆包
答：

粘包
- 发送方产生粘包，当发送的数据包过于小时（TCP会采用Nagle算法），将这些较小的数据包进行合并发送。合并发送会在发送缓冲区中进行。
- 接收方产生粘包，放数据的速度>（应用层）拿数据的速度，在接收缓冲区进行

MTU：（通信协议中）最大传输单元  （与数据链路层有关，普通以太网MTU是1500字节）

MSS：TCP建立连接后，双方约定可传输的最大TCP报文长度

拆包：如果数据包太大，超过了MSS的大小，就会被拆分成多个TCP报文分开传输

### 粘包、拆包解决办法
答：
1. 在发送端给每个数据包添加包首部，首部中至少包含数据包的长度
2. 在发送端将每个数据包封装为固定长度
3. 可以在数据包之间设置边界，eg:添加特殊符号

### ARQ协议
答：ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议（，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。）

停止等待ARQ：一次只发送一个分组消息，等待对方确定后再继续发后面的，如果没收到确认会超时重传。
缺点：信道利用率很低，传输延时大。

连续ARQ协议：这个协议会连续发送一组数据包，然后再等待这些数据包的ACK，不必每发完一个分组就停下来等待对方确认。接收方一般都是采用累积确认的方式。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，**对按序到达的最后一个分组发送确认**。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。

优点是容易实现，即使确认丢失也不必重传。缺点：不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。比如发送方发送了前5个分组，而中间的第3个分组丢失了，这时候接收方只能对前2个发出确认。而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫Go-back-N（回退N），表示需要再退回来重传已发送过的N个分组。


### 打开一个网页，整个过程会使用哪些协议？
答：
1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

### DNS服务器基本流程
答：
1. 用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端了
2. 浏览器将接收到的url中抽取出域名字段，就是访问的主机名，比如
http://www.baidu.com/
, 并将这个主机名传送给DNS应用的客户端
3. DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）
4. 该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址
5. 一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接

### get和post的区别
答：get参数放在URL中，并且只请求一次，post参数放在request body中，请求两次。get只能进行URL编码，参数会被完整保留历史记录，长度有限，数据类型只能是ASCLL字符，不安全，不能传递敏感信息。post支持多种编码，参数不会保留记录，长度无限制，数据类型无限制。

### cookies和session的关系
答：Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

- Cookie 一般用来保存用户信息 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。
- Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。

### 服务器怎么知道客户端已经发送数据完毕？
答：

### 数字证书、签名
答：数字签名：用私钥加密消息（，用公钥解密消息）（解决完整性，有效性）

数字证书，包含公钥，公钥的数字签名，公钥拥有者的信息。若证书验证成功，则合法。

### 状态码
答：![image](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png)

### HTTP长连接,短连接
答：本质上是TCP的长连接，短连接。在HTTP1.1及之后默认是长连接，所谓长连接指的是复用，短连接指的是客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。（并发量大，但每个用户无需频繁操作情况下需用短连接好）
[http的长连接和短连接（史上最通俗！）](https://www.jianshu.com/p/3fc3646fad80)

### HTTP 1.0、HTTP 1.1和HTTP2.0的主要区别是什么?
答：

HTTP1.0和HTTP1.1区别：

1. HTTP1.1默认是长连接（在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟），HTTP1.0是短连接（每次请求都要创建连接的缺点）
2. Http1.1更节约带宽，（ HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。）
3. HTTP1.1请求和响应都支持Host域，HTTP1.0没有Host域。（HTTP1.0认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）；HTTP1.1存在虚拟主机，并共享IP）
4. HTTP1.1则引入了更多的缓存控制策略，例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略；HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准
5. HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

HTTP 1.1和HTTP2.0的区别：

1. 多路复用，HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
2. 头部数据压缩， HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
3. 服务器推送，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

[HTTP1.0和HTTP1.1和HTTP2.0的区别](https://blog.csdn.net/ailunlee/article/details/97831912)


### HTTP 和 HTTPS 的区别？
答：
1. 端口，HTTP默认是80端口，HTTPS默认是443端口
2. 加密，HTTP明文传输，HTTPS加密传输
3. 资源消耗，HTTPS更消耗系统资源，申请需要money


### http请求报文有什么？
答：![image](https://s3.51cto.com/wyfs02/M02/22/DA/wKioL1MpX-qwK1-PAAExXPRpR8M814.jpg)
**请求行**：请求行由方法字段、URL字段和HTTP协议版本字段。（其中，方法字段严格区分大小写，当前HTTP协议中的方法都是大写，方法字段如下介绍如下：

**方法字段**

①GET:请求获取Request-URI(URI:通用资源标识符,URL是其子集，URI注重的是标识，而URL强调的是位置，可以将URL看成原始的URI),所标识的资源

②POST：在Request-URI所标识的资源后附加新的数据；支持HTML表单提交，表单中有用户添入的数据，这些数据会发送到服务器端，由服务器存储至某位置（例如发送处理程序）

③HEAD:请求Request-URI所标识的资源响应消息报头，HEAD方法可以在响应时不返回消息体。

④PUT：与GET相反，请求服务器存储一个资源，并用Request-URI做为其标识；例如发布系统。

⑤DELETE：请求删除URL指向的资源

⑥OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项
⑦TRACE：跟踪请求要经过的防火墙、代理或网关等，主要用于测试或诊断

⑧CONNECT保留将来使用）

**URL**

一个完整的包括类型、主机名和可选路径名的统一资源引用名，如：http://www.example.com/path/to/file.html

**请求头部**：位于请求行的下面

请求报文中常见的标头有：

Connetion标头（连接管理）、Host标头（指定请求资源的主机）、Range标头（请求实体的字节范围）、User-Agent标头（包含发出请求的用户信息）、Accept标头（首选的媒体类型）、Accept-Language(首选的自然语言)

**实体**：位于首部行之后

实体包含了Web客户端请求的对象。Content-Length标头及Content-Type标头用于计算实体的位置、数据类型和数据长度。当Web服务器接收到Web客户端的请求报文后，对HTTP请求报文进行解析，并将Web客户端的请求的对象取出打包，通过HTTP响应报文将数据传回给Web客户端，如果出现错误则返回包含对应错误的错误代码和错误原因的HTTP响应报文。

[http报文详解](https://www.cnblogs.com/kageome/p/10859996.html)

### http缓存
答：

[HTTP 缓存机制](https://zhuanlan.zhihu.com/p/58685072)

### TCP中的缓存有什么作用？
1. TCP缓冲区是什么

每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。

2. 缓冲区的意义（作用）

TCP套接字的IO缓冲区示意图
![image](https://static.nowcoder.com/images/activity/2021jxy/java/img/asset/TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84IO%E7%BC%93%E5%86%B2%E5%8C%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)
TCP套接字的I/O缓冲区示意图

**TCP的发送缓冲区是用来缓存应用程序的数据，发送缓冲区的每个字节都有序列号，被应答确认的序列号对应的数据会从发送缓冲区删除掉。**

write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。

TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，比如nagle算法，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。

 read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。

3. I/O缓冲区特性

（1）I/O缓冲区在每个TCP套接字中单独存在；

（2）I/O缓冲区在创建套接字时自动生成；

（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据；

（4）关闭套接字将丢失输入缓冲区中的数据。

输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：

2021-7-16添加

### ISN（Initial Sequence Number）是固定的吗？
答：
  三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

      如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

### 什么是半连接队列？  
答：
服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

 这里在补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, …

### 三次握手过程中可以携带数据吗？
答：
很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。
而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。



### TCP首部

![image-20210817180413012](../../../asserts/计算机网络/image-20210817180413012.png)



### UDP首部

![image-20210817180521164](../../../asserts/计算机网络/image-20210817180521164.png)



IP报文段

![image-20210817180543694](../../../asserts/计算机网络/image-20210817180543694.png)



相关知识

![image-20210817180616839](../../../asserts/计算机网络/image-20210817180616839.png)

